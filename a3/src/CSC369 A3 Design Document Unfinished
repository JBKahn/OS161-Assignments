CSC369 A3 Design Document
Joseph Kahn and Adrian Paulozza

Discuss the single biggest challenge you had to address for the assignment

How our open file table design supports fork semantics:
The filetable is accessable through a pointer in the current thread and thus when fork is called, a new file table is created and all the data is copied from the parent's copy to the child's copy. While the spinlock and filecount are copied to new places in memory, the refrence count, vnode and positions in the file use the same pointer so that the parent and child will have the same values. The refrence count to that file in incrimented by one and this ensures that either one exiting will not close the file as the OS will not close a file if there are any other processes using it. All of these operations are done within a spinlock to avoid syncronization issues.

How our mplementation of sfs_getdirentry works:
First we check if it is a diretory type, and if is not we return the error code ENOTDIR. Then we check that the slot indicated by the offset is not out of bounds by ensuring that it lies within the number of entries in this directory, using the sfs_dir_nentries() function. Then we itterate over those slots that are within range, starting at the offset (until we run out of space, in which case we simply return 0) until we find a non-empty slot. When we find the non-empty slot we break out of the loop and use uiomove to get it into the uio struct. Then we update the offset, as instructed in the vnode.h description of what getdirentry should do.

Changes we needed to make to use wasted inode space to store file data:
Changes we inteded to make (the code written is in sfs_io and sfs_truncate but commented out as it does not currently work):
- sfs_io should recalcualte the offset based on it's initial value. If it's within SFS_INLINEBYTES then it should read within the inode and if it is not then SFS_INLINEBYTES should be subtracted from it. This corrects for the location of the data after moving a portion of it into the inode. Then after all operations are done, the offset should be reset to the unaugmented value but adding SFS_INLINEBYTES back to it.
- In sys_trucate we should mark the inode as dirty so that they will be written back to disk during a sync operation.

The single biggest challenge we had to address for the assignment:
A tie: mould and inodes.
On one hand mould problems lead to a lack of time for OS work.
On the other hand, sfs_vnops.c parsing took the longest amount of time to do and we still have not implimented the inode portion of the assignment. Figuring out the exact places to change the calculations and tweak the uio struct is difficult to figure out. Lots of time was spent simply reading the fucntions and attempting to follow them but this was to no avail.

Not finished:
The inode efficient storing to not waste space.