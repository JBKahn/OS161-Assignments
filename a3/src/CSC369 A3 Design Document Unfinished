CSC369 A3 Design Document
Joseph Kahn and Adrian Paulozza

Discuss the single biggest challenge you had to address for the assignment

How our open file table design supports fork semantics:
The filetable is accessable through a pointer in the current thread and thus when fork is called, a new file table is created and all the data is copied from the parent's copy tot he child's copy. While the spinlock and filecount are copied to new places in memory, the refrence count, vnode and positions in the file use the same pointer so that the parent and child will have the same values. The refrence count to that file in incrimented by o ne and this ensures that either one exiting will not close the file as the OS will not close a file if there are any other processes using it.

How our mplementation of sfs_getdirentry works:
First we check if it is a diretory type, and if is not we return the error code ENOTDIR. Then we check that the slot indicated by the offset is not out of bounds by ensuring that it lies within the number of entries in this directory, using the sfs_dir_nentries() function. Then we itterate over those slots that are within range, starting at the offset (until we run otu of space, in which case we simply return 0) until we find a non-empty slot. When we find the non-empty slot we break out of the loop and use uimove to get it into the uio struct. Then we update the offset, as instructed in the vnode.h description of what getdirentry should do.

Changes we needed to make to use wasted inode space to store file data:
None yet. Confused. We know to add the char array into the struct but not yet what to do with it.

The single biggest challenge we had to address for the assignment:
The initial parsing of the vnode info and various function we were supposed to use. There was a lot of searching around and following function calls. This was especially true of the inode wated space in which it is hard to find what to do.

Not finished:
The inode efficient storing to not waste space.